% Nome do capítulo
\chapter{Introdução}
% Label para referenciar
\label{introducao}

% Diminuir espaçamento entre título e texto
\vspace{-1.9cm}

% Texto do capítulo
  
  A internet como mídia de comunicação, possui o mais amplo de todos os alcances, 
  conforme pode ser visto na pesquisa do IBGE de 2005 para 2011, 
  o número de internautas cresceu 143.8\%  e o de pessoas com celular, 107.2\%. 
  E para continuar a oferecer serviços e informações, com rapidez e até mesmo em tempo real, 
  é necessário se preocupar com a quantidade de milhões de usuários simultâneos, 
  que cresce exponencialmente, e vencer barreiras tecnológicas de escalabilidade e desempenho nos servidores.
  
  Em sistemas web desenvolvidos sob as plataformas tradicionais como JAVA, \ac{PHP}, .NET dentre outros 
  é necessário paralisar um processamento enquanto utiliza uma entrada e saída do servidor. 
  Essa paralisação é conhecida como um modelo bloqueante. Exemplificando este modelo, em um servidor Web 
  que cada processo é uma requisição de feita pelo usuário. Com o decorrer novos usuários realizam novas 
  requisições aumentando o processamento. No modelo bloqueante cada requisição é enfileirada e depois 
  processadas uma a uma. Enquanto uma requisição esta sendo processada as demais ficam em espera, 
  mantendo-se ociosas por um período indeterminado na fila.\cite{Pereira:2013}
  
  Com esta arquitetura tradicional, gasta-se muito tempo mantendo uma fila de espera com processos ociosos,
  tais como: envio de e-mails, consultas em banco de dados, leitura em disco que não liberam recursos enquanto
  não forem finalizadas. Com o aumento dos acessos ao sistema é necessário fazer uma atualização
  do hardware (equipamento).\cite{Pereira:2013}
  
  \citeonline{Abernethy:2011}, explica que em linguagens como Java e PHP, cada conexão cria-se uma 
  nova \textit{thread} com 2 MB de memória RAM. Se em um servidor possuir 8 GigaBytes de memória RAM, 
  teoricamente o número máximo de conexões concorrentes é aproximadamente 4.000 usuários. 
  Com o aumento da base de cliente, e claro, se quiser que o aplicativo web suporte mais usuários, é necessário 
  adicionar mais e mais servidores. Como foi descrito, o gargalo em toda a arquitetura 
  da aplicação web ( incluindo a velocidade de tráfego, velocidade do processador e velocidade da memória RAM) 
  estaria associado ao número máximo de conexões concorrentes que um servidor pode manipular.
  
  Portanto, observa-se que o escalonamento horizontal, adicionando novos servidores, além do custo altíssimo, 
  torna a arquitetura do sistema complexa pois será necessário acrescentar servidores de balanceamento, 
  rede estruturada da central de dados que seja capaz de suportar um alto tráfego e acompanhamento dos processos 
  do sistema de perto para que os bloqueios sejam consertados em tempo hábil. A utilização de escalonamento vertical, 
  ou melhor, atualização de hardware – colocando mais processadores ou memória - pode inviabilizar a arquitetura do 
  sistema, visto que há uma barreira de hardware, mais especificamente, placas-mãe que não suportam mais de 8 slots 
  de memória ou determinados modelos de memória RAM, suporte a processadores com mais de 7 núcleos. 
  Além dessas limitações tecnológicas, ha o agravante do alto custo para atualizar este hardware. 
  Processadores com 7 núcleos são caros e dependendo dos casos é necessário trocar todo o equipamento - hardware - 
  para garantir o devido funcionamento dos componentes.
  
  Como dito por \cite{Oliveira:2012} surgiu a necessidade de melhorar em nível de software para permitir que a aplicação
  receba um grande número de conexões simultâneas, escalável e baixo consumo de memória RAM.
  
  Pretende-se com esta proposta de pesquisa investigar e elaborar aplicações para a internet, 
  utilizando o servidor Node.Js e comparar a sua performance em relação ao desenvolvimento
  de aplicativos tradicionais.
  
  
\section{Motivação}
\label{motivacao}
  
  Com alto crescimento da internet e de serviços web em REST tem-se os aplicativos web tem a necessidade de ter
  uma arquitetura, de baixo custo em hardware, escalável e que seja capaz de suportar milhares de usuários 
  sem perdas de dados ou conexões. 
  
\section{Objetivos}
\label{objetivos}

\subsection{Objetivos Geral}

  Pretende-se com esta pesquisa investigar, comparar e demonstrar a capacidade 
  do ambiente Node.Js de processar e responder milhares de requisições comparando-o com um ambiente Python.
  
  Para isso serão utilizados dois aplicativos desenvolvidos como uma API RESTFul provendo as operações
  básicas como \ac{CRUD} de uma lista de contatos.
  
\subsection{Objetivos específicos}

  Os objetivos específicos deste trabalho são:
  
    \begin{compactitem}
      \item[a)] Estudo teórico do ambiente de desenvolvimento Node.Js para construção do protótipo 
      \item[b)] Propor dois protótipos e comparár a sua forma de desenvolvimento.
      \item[b)] Realizar testes de carga nos protótipos para verificar a perfomance com um alto número de conexões,
      seu comportamento em relação ao consumo de hardware e apresentá-los ao leitor.
    \end{compactitem}
  
  
\section{Organização}
\label{organizacao}  

  Para contextualizar o leitor, o Capítulo \ref{ambiente-node-js} aborda o referêncial teórico e fontes de estudos utilizados para iniciar com o ambiente 
  Node.Js. Já o Capítulo \ref{desenvolvimento-prototipos} compreende a lista de requisitos e especificações do protótipo a ser construído e o
  desenvolvimento. O Capítulo \ref{experimentos-resultados} descreve os testes realizados e os resultados obtidos. 
  Por fim, o Capítulo \ref{}, conclui o trabalho acadêmico.